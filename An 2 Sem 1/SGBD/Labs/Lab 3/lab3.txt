--3. Creați un bloc anonim care să afișeze propoziția "Invat PL/SQL" pe ecran.

--v1

VARIABLE g_mesaj VARCHAR2(50) 
BEGIN :g_mesaj := 'Invat PL/SQL'; 
END; 
/ 
PRINT g_mesaj;


--v2

BEGIN DBMS_OUTPUT.PUT_LINE('Invat PL/SQL'); 
END; 
/

--4. Definiți un bloc anonim în care să se afle numele departamentului cu cei mai mulți angajați. 
--Comentați cazul în care există cel puțin două departamente cu număr maxim de angajați.

DECLARE 
v_dep departments.department_name%TYPE; 
BEGIN 
    SELECT department_name 
    INTO v_dep 
    FROM employees e, departments d 
    WHERE e.department_id=d.department_id 
    GROUP BY department_name 
    HAVING COUNT(*) <> (SELECT MAX(COUNT(*)) 
                        FROM employees 
                        GROUP BY department_id); 
    DBMS_OUTPUT.PUT_LINE('Departamentul '|| v_dep); 
    EXCEPTION 
        when too_many_rows then DBMS_OUTPUT.PUT_LINE('Prea multe linii!');
        when no_data_found then DBMS_OUTPUT.PUT_LINE('Nimic');
END; 
/

--5. Rezolvați problema anterioară utilizând variabile de legătură. Afișați rezultatul atât din bloc, 
--cât și din exteriorul acestuia.

VARIABLE rezultat VARCHAR2(35) 
BEGIN 
    SELECT department_name 
    INTO :rezultat
    FROM employees e, departments d 
    WHERE e.department_id=d.department_id 
    GROUP BY department_name 
    HAVING COUNT(*) = (SELECT MAX(COUNT(*)) 
                       FROM employees 
                       GROUP BY department_id); 
    DBMS_OUTPUT.PUT_LINE('Departamentul '|| :rezultat); 
END; 
/ 
PRINT rezultat

--6. Modificați exercițiul anterior astfel încât să obțineți și numărul de angajați din departamentul respectiv.
DECLARE
v_dep departments.department_name%TYPE;
v_nr number;
BEGIN 
    SELECT department_name, count(*)
    INTO v_dep, v_nr
    FROM employees e, departments d 
    WHERE e.department_id=d.department_id 
    GROUP BY department_name 
    HAVING COUNT(*) = (SELECT MAX(COUNT(*)) 
                       FROM employees 
                       GROUP BY department_id); 
    DBMS_OUTPUT.PUT_LINE('Departamentul '|| v_dep || ' are ' || v_nr || ' angajati.'); 
END; 
/ 
PRINT rezultat

--7. Determinați salariul anual și bonusul pe care îl primește un 
--salariat al cărui cod este dat de la tastatură. Bonusul este 
--determinat astfel: dacă salariul anual este cel puțin 200001, 
--atunci bonusul este 20000; dacă salariul anual este cel puțin 100001 și cel mult 200000, 
--atunci bonusul este 10000, iar dacă salariul anual este cel mult 100000, 
--atunci bonusul este 5000. Afișați bonusul obținut. 
--Comentați cazul în care nu există niciun angajat cu codul introdus.
--Obs. Se folosește instrucțiunea IF.

SET VERIFY OFF 
DECLARE 
    v_cod employees.employee_id%TYPE:=&p_cod; 
    v_bonus NUMBER(8); 
    v_salariu_anual NUMBER(8); 
BEGIN 
    SELECT salary*12 
    INTO v_salariu_anual 
    FROM employees 
    WHERE employee_id = v_cod; 
    IF v_salariu_anual>=200001 
        THEN v_bonus:=20000; 
    ELSIF v_salariu_anual BETWEEN 100001 AND 200000 
        THEN v_bonus:=10000; 
    ELSE v_bonus:=5000; 
    END IF; 
DBMS_OUTPUT.PUT_LINE('Bonusul este ' || v_bonus); 
END; 
/ 
SET VERIFY ON;

--8. Rezolvați problema anterioară folosind instrucțiunea CASE.

SET VERIFY OFF 
DECLARE 
    v_cod employees.employee_id%TYPE:=&p_cod; 
    v_bonus NUMBER(8); 
    v_salariu_anual NUMBER(8); 
BEGIN 
    SELECT salary*12 
    INTO v_salariu_anual 
    FROM employees 
    WHERE employee_id = v_cod; 
    CASE 
        WHEN v_salariu_anual>=200001 THEN v_bonus:=20000; 
        WHEN v_salariu_anual BETWEEN 100001 AND 200000 THEN v_bonus:=10000; 
        ELSE v_bonus:=5000; 
    END CASE; 
DBMS_OUTPUT.PUT_LINE('Bonusul este ' || v_bonus); 
END; 
/ 
SET VERIFY ON;

--9. Scrieți un bloc PL/SQL în care stocați prin variabile de substituție un cod de angajat, un cod de departament și 
--procentul cu care se mărește salariul acestuia. Să se mute salariatul în noul departament și să i se crească salariul în mod corespunzător. 
--Dacă modificarea s-a putut realiza (există în tabelul emp_*** un salariat având codul respectiv) să se afișeze mesajul “Actualizare realizata”, 
--iar în caz contrar mesajul “Nu exista un angajat cu acest cod”. Anulați modificările realizate.

DEFINE p_cod_sal= 200 
DEFINE p_cod_dept = 80 
DEFINE p_procent =20 
DECLARE 
    v_cod_sal emp_ttu.employee_id%TYPE:= &p_cod_sal; 
    v_cod_dept emp_ttu.department_id%TYPE:= &p_cod_dept; 
    v_procent NUMBER(8):=&p_procent;

BEGIN 
    UPDATE emp_ttu
    SET department_id = v_cod_dept, 
        salary=salary + (salary* v_procent/100) 
    WHERE employee_id= v_cod_sal; 
    IF SQL%ROWCOUNT =0 
        THEN DBMS_OUTPUT.PUT_LINE('Nu exista un angajat cu acest cod'); 
    ELSE DBMS_OUTPUT.PUT_LINE('Actualizare realizata'); 
    END IF; 
END; 
/
ROLLBACK;

select * from emp_ttu;
select * from employees;

--10. Creați tabelul zile_***(id, data, nume_zi). Introduceți în tabelul zile_*** 
--informațiile corespunzătoare tuturor zilelor care au rămas din luna curentă.

create table zile_ttu (id number, data date, nume_zi varchar2(30));

select * from zile_ttu;

DECLARE 
    contor NUMBER(6) := 1; 
    v_data DATE; 
    maxim NUMBER(2) := LAST_DAY(SYSDATE)-SYSDATE; 
BEGIN 
    LOOP 
        v_data := sysdate+contor; 
        INSERT INTO zile_ttu 
        VALUES (contor,v_data,to_char(v_data,'Day')); 
        contor := contor + 1; 
        EXIT WHEN contor > maxim; 
    END LOOP; 
END;
/

select * from zile_ttu;

rollback;

--11. Rezolvați cerința anterioară folosind instrucțiunea WHILE.

DECLARE 
    contor NUMBER(6) := 1; 
    v_data DATE; 
    maxim NUMBER(2) := LAST_DAY(SYSDATE)-SYSDATE; 
BEGIN 
    WHILE contor <= maxim LOOP 
        v_data := sysdate+contor; 
        INSERT INTO zile_ttu 
        VALUES (contor,v_data,to_char(v_data,'Day'));
        contor := contor + 1; 
    END LOOP; 
END;
/

select * from zile_ttu;

rollback;

--12. Rezolvați cerința anterioară folosind instrucțiunea FOR.

DECLARE 
    v_data DATE; 
    maxim NUMBER(2) := LAST_DAY(SYSDATE)-SYSDATE; 
BEGIN
    FOR contor IN 1..maxim LOOP 
        v_data := sysdate+contor; 
        INSERT INTO zile_ttu 
        VALUES (contor,v_data,to_char(v_data,'Day')); 
    END LOOP; 
END;
/

select * from zile_ttu;

--13. Să se declare și să se inițializeze cu 1 variabila i de tip POZITIVE și cu 10 constanta max_loop de tip POZITIVE. 
--Să se implementeze un ciclu LOOP care incrementează pe i până când acesta ajunge la o valoare > max_loop, 
--moment în care ciclul LOOP este părăsit și se sare la instrucțiunea i:=1.

--var 1

DECLARE 
    i POSITIVE:=1; 
    max_loop CONSTANT POSITIVE:=10; 
BEGIN 
    LOOP 
        i:=i+1; 
        IF i>max_loop 
            THEN DBMS_OUTPUT.PUT_LINE('in loop i=' || i); 
            GOTO urmator; 
        END IF; 
    END LOOP; 
<<urmator>> 
i:=1; 
DBMS_OUTPUT.PUT_LINE('dupa loop i=' || i); 
END;
/

--var 2

DECLARE 
    i POSITIVE:=1; 
    max_loop CONSTANT POSITIVE:=10; 
BEGIN 
    i:=1; 
    LOOP 
        i:=i+1; 
        DBMS_OUTPUT.PUT_LINE('in loop i=' || i); 
        EXIT WHEN i>max_loop; 
    END LOOP; 
    i:=1; 
    DBMS_OUTPUT.PUT_LINE('dupa loop i=' || i);
END;
/

--TEMA (Exercitii)

--1.
--a) 2
--b) text 2
--c) text 3 adaugat in sub-bloc
--d) 101
--e) text 1 adaugat in blocul principal
--f) text 2 adaugat in blocul principal

--2.
--a.

select to_char(z.ziua, 'dd/mm/yyyy') "Ziua" , count(r.book_date) "Nr imprumuturi"
from rental r right join (select trunc(sysdate, 'month') + level -1 ziua
                          from dual
                          connect by level <= extract (day from last_day(sysdate))
                          ) z 
                          on (to_char(r.book_date, 'dd/mm/yyyy') = to_char(z.ziua, 'dd/mm/yyyy'))
group by to_char(z.ziua, 'dd/mm/yyyy')
order by to_char(z.ziua, 'dd/mm/yyyy');
--b.

create table octombrie_ttu (id number, data date);

select * from octombrie_ttu;

declare
    n number := extract (day from last_day(sysdate));
    d date := trunc(sysdate, 'month');
begin
    for i in 1..n loop
        insert into octombrie_ttu 
        values (i, d);
        d := d + 1;
    end loop;
end;
/





