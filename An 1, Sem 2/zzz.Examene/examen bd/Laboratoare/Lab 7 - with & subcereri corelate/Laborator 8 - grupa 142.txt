--LABORATOR 5
0. a) Să se afişeze informaţii despre angajaţii al căror salariu depăşeşte valoarea medie a salariilor 
colegilor săi de departament.

SELECT last_name, salary, department_id
FROM employees e
WHERE salary > (SELECT AVG(salary)
                FROM employees
                WHERE department_id = e.department_id);
                
                
b) Analog cu cererea precedentă, afişându-se şi numele departamentului şi 
media salariilor acestuia şi numărul de angajaţi.

--Soluţia 1 (subcerere necorelată în clauza FROM):
SELECT last_name, salary, e.department_id, department_name, sal_med, nr_sal
FROM employees e, departments d, (SELECT department_id, round(AVG(salary)) sal_med, COUNT(*) nr_sal
                                  FROM employees
                                  GROUP BY department_id
                                  ) ac
WHERE e.department_id = d.department_id
      AND d.department_id = ac.department_id
      AND salary > (SELECT AVG(salary)
                    FROM employees
                    WHERE department_id = e.department_id
                    );


--Soluţia 2 (subcerere corelată în clauza SELECT):
--Vezi in laborator 5 pag 3

1. Să se afişeze numele şi salariul angajaţilor al căror salariu este mai mare decât 
salariile medii din toate departamentele. 
Se cer 2 variante de rezolvare: cu operatorul ALL sau cu funcţia MAX.

--ALL
select last_name, salary
from employees
where salary >ALL(select avg(salary)
                 from employees
                 group by department_id);

--MAX
select last_name, salary
from employees
where salary > (select max(avg(salary))
               from employees
               group by department_id);

2. Sa se afiseze numele si salariul celor mai prost platiti angajati din fiecare departament.

--Soluţia 1 (cu sincronizare):
SELECT last_name, salary, department_id
FROM employees e
WHERE salary = (SELECT MIN(salary)
                FROM employees
                WHERE department_id = e.department_id);
                
                
--Soluţia 2 (fără sincronizare):
SELECT last_name, salary, department_id
FROM employees
WHERE (department_id, salary) IN (SELECT department_id, MIN(salary)
                                  FROM employees
                                  GROUP BY department_id);
                                  
                                  
--Soluţia 3: Subcerere în clauza FROM
SELECT last_name, salary, e.department_id
FROM employees e join (select min(salary) min_sal, department_id dep_id
                       from employees
                       group by department_id)
                on (e.department_id = dep_id)
WHERE salary = min_sal;

--SAU:
SELECT last_name, salary, e.department_id
FROM employees e join (select min(salary) min_sal, department_id
                       from employees
                       group by department_id
                       )e2
                on (e.department_id = e2.department_id)
WHERE salary = min_sal;

3. Sa se obtina numele salariatilor care lucreaza intr-un departament in care exista cel putin 1 angajat 
cu salariul egal cu salariul maxim din departamentul 30.

-- IN
select last_name, salary, department_id
from employees 
where department_id IN (select department_id
                        from employees
                        where salary = (select max(salary)
                                        from employees
                                        where department_id = 30
                                        )
                        and department_id != 30
                       );

--EXISTS
select last_name, salary, department_id
from employees e
where EXISTS (  select 1
                from employees
                where e.department_id = department_id
                salary = (select max(salary)
                                from employees
                                where department_id = 30
                                )
                and department_id != 30
               );

x -> y true

select 1 from employees;

4. Sa se obtina numele primilor 3 angajati avand salariul maxim. 
Rezultatul se va afişa în ordine crescătoare a salariilor.


--Solutia 1: subcerere sincronizată
--numaram cate salarii sunt mai mari decat salariul de pe linia la care suntem
select last_name, salary, rownum
from employees e
where 3 > (select count(salary)
           from employees
           where e.salary < salary)
        and rownum < 4;



--Solutia 2: vezi analiza top-n (mai jos)
-- primii 3 angajati cu salariul maxim inseamna primii 3 ang care au primele 3 cele mai mari salarii din firma

select last_name, salary, rownum
from (select last_name, salary
      from employees
      order by salary desc)
where rownum < 4;

6. Să se determine locaţiile în care se află cel puţin un departament.

-- IN
select location_id
from locations
where location_id IN (select location_id 
                      from departments);

--EXISTS
select location_id
from locations l
where EXISTS (select 1
              from departments
              where l.location_id = location_id);


7. Să se determine departamentele în care nu există nici un angajat.

--NOT EXISTS
SELECT department_id, department_name
FROM departments d  -- department_id este cheie primara deci este o lista unica cu toate departamentele
WHERE NOT EXISTS (SELECT 'x'
                  FROM employees  -- department_id este cheie externa deci sunt departamentele cu angajati
                  WHERE department_id = d.department_id
                  );
-- => in final o sa obtinem departamentele fara angajati

--NOT IN
SELECT department_id, department_name
FROM departments  
WHERE department_id NOT IN (SELECT department_id
                            FROM employees 
                            WHERE department_id is not null
                           );
                       
 --SAU    
SELECT department_id, department_name
FROM departments  
WHERE department_id NOT IN (SELECT nvl(department_id, 0)
                            FROM employees 
                            );

--in momentul in care utilizam NOT IN 
--trebuie sa avem grija la valorile null din subcerere
--adica le putem elimina sau inlocui

--MINUS
SELECT department_id
FROM departments  -- din lista tuturor departamentelor

MINUS  -- eliminam

SELECT department_id
FROM employees;  -- depaetamentele in care lucreaza angajati

--- => departamentele FARA angajati


--CLAUZA WITH
8. Utilizând clauza WITH, să se scrie o cerere care afişează 
numele departamentelor şi valoarea totală a salariilor din cadrul acestora. 
Se vor considera departamentele a căror valoare totală a salariilor este mai mare 
decât media valorilor totale ale salariilor tuturor angajatilor.

--numele departamentelor şi valoarea totală a salariilor din cadrul acestora
WITH val_dep AS (SELECT department_name, SUM(salary) AS total
                 FROM departments d join employees e ON (d.department_id = e.department_id)
                 GROUP BY department_name
                 ),
                 
val_medie AS (SELECT SUM(total)/COUNT(*) AS medie
              FROM val_dep)
              
SELECT *
FROM val_dep
WHERE total > (SELECT medie
               FROM val_medie)
ORDER BY department_name;

Tema: Laborator 5: ex: 5, 9, 10, 11, 12, 14
Deadline: Duminica: 12.04 (inclusiv)

