{-
Gasiti mai jos limbajul unui minicalculator si o interpretare partiala. 
Calculatorul are doua celule de memorie, care au valoarea initiala 0. Expresia `Mem := Expr` are urmatoarea semantica: 
`Expr` este evaluata, iar valoarea este pusa in `Mem`.  
Un program este o expresie de tip `Prog`iar rezultatul executiei este dat de valorile finale ale celulelor de memorie.
Testare se face apeland `run test`. 
-}

data Prog  = Stmt ::: Prog | Off
data Stmt  = Mem := Expr
data Mem = Mem1 | Mem2 
data Expr  =  M Mem | V Int | Expr :+ Expr

infixl 6 :+
infix 3 :=
infixr 2 :::

type Env = (Int,Int)   -- corespunzator celor doua celule de memorie (Mem1, Mem2)

  
expr ::  Expr -> Env -> Int
expr (e1 :+  e2) m = expr  e1 m + expr  e2 m
expr _ _ = undefined

stmt :: Stmt -> Env -> Env
stmt _ _ = undefined


prog :: Prog -> Env -> Env
prog Off m = m
prog _ _ = undefined

run :: Prog -> Env
run p = prog p (0, 0)


test1 = Mem1 := V 3 ::: Mem2 := M Mem1 :+ V 5 ::: Off
test2 = Mem2 := V 3 ::: Mem1 := V 4 ::: Mem2 := (M Mem1 :+ M Mem2) :+ V 5 ::: Off
test3 = Mem1 := V 3 :+  V 3 ::: Off

{-CERINTE

1) (10pct) Finalizati definitia functiilor de interpretare.
2) (10 pct) Adaugati expresia `e1 :/ e2` care evaluează expresiile e1 și e2, apoi
  - dacă valoarea lui e2 e diferită de 0, se evaluează la câtul împărțirii lui e1 la e2;
  - în caz contrar va afișa eroarea "împarțire la 0" și va încheia execuția.
3)(20pct) Definiti interpretarea  limbajului extins astfel incat executia unui program fara erori sa intoarca valoarea finala si un mesaj
   care retine toate modificarile celulelor de memorie (pentru fiecare instructiune `m :< v` se adauga 
   mesajul final `Celula m a fost modificata cu valoarea v`), mesajele pastrand ordine de efectuare a instructiunilor.  
    Rezolvați subiectul 3) în același fișier redenumind funcțiile de interpretare. 

Indicati testele pe care le-ati folosit in verificarea solutiilor. 

-}


-- urmatorul

```{-
Gasiti mai jos limbajul unui minicalculator si o interpretare partiala. 
Calculatorul are doua celule de memorie. Interpretarea instructiunilor este data mai jos. 

Un program este o expresie de tip Progiar rezultatul executiei este starea finala a memoriei
Testare se face apeland prog test. 
-}

type Env = (Int,Int)   -- corespunzator celor doua celule de memorie

data Prog  = On Env Stmt  -- Env reprezinta valorile initiale ale celulelor de memorie
data Stmt
    = Off
    | Expr :<< Stmt -- evalueaza Expr, pune rezultatul in Mem1, apoi executa Stmt
    | Expr :< Stmt  -- evalueaza Expr, pune rezultatul in Mem2, apoi executa Stmt
data Mem = Mem1 | Mem2 
data Expr  =  M Mem | V Int | Expr :+ Expr

infixl 6 :+
infixr 2 :<
infixr 2 :<<




expr ::  Expr -> Env -> Int
expr (e1 :+  e2) m = expr e1 m + expr e2 m
expr   = undefined

stmt :: Stmt -> Env -> Env
stmt Off m = m
stmt   = undefined

prog :: Prog -> Env
prog (On m s) = undefined


test1 = On (1,2) (V 3 :< M Mem1 :+ V 5 :<< Off)
test2 = On (0,0) (V 3 :<< M Mem2 :+ V 5 :< Off)
test3 = On (0,1) (V 3 :<< V 4 :< M Mem1 :+ M Mem2 :+ (V 5) :< Off)
test4 = On (-2,3)(M Mem1  :+  V 3 :< Off)

{-CERINTE

1) (10pct) Finalizati definitia functiilor de interpretare.
2) (10 pct) Adaugati expresiile If1 e1 e2 si If2 e1 e2  care evaluează  e1 daca Mem1, 
respectiv Mem2, este nenula sie2 in caz contrar.
3) (20pct) Definiti interpretarea  limbajului extins  astfel incat executia unui program  sa calculeze memoria finala,
  si numărul de accesări (scrieri și citiri) ale memoriilor Mem1 si Mem2 (se va calcula o singura
  valoare, insumand accesarile ambelor memorii, fara a lua in considerare initializarea). 
  Rezolvați subiectul 3) în același fișier, redenumind funcțiile de interpretare. 


Indicati testele pe care le-ati folosit in verificarea solutiilor. 

-}```

-- al 3 -lea

{-
Gasiti mai jos  un minilimbaj. Interpretarea este partial definita.
Un program este o expresie de tip Pgmiar rezultatul executiei este ultima stare a memoriei. 
Executia unui program se face apeland pEval.
-}

import Data.Maybe
import Data.List

type Name = String

data  Pgm  = Pgm [Name] Stmt
        deriving (Read, Show)

data Stmt = Skip | Stmt ::: Stmt | If BExp Stmt Stmt| Name := AExp
        deriving (Read, Show)

data AExp = Lit Integer | AExp :+: AExp | AExp :: AExp | Var Name
        deriving (Read, Show)

data BExp = BTrue | BFalse | AExp :==: AExp | Not BExp
        deriving (Read, Show)

infixr 2 :::
infix 3 :=
infix 4 :==:
infixl 6 :+:
infixl 7 ::


type Env = [(Name, Integer)]


 


aEval :: AExp -> Env -> Integer
aEval = undefined

bEval :: BExp -> Env -> Bool
bEval = undefined

sEval :: Stmt -> Env -> Env
sEval Skip env = env
sEval (st1 ::: st2) env = undefined
sEval (If b st1 st2) env =  if (bEval b env) then (sEval st1 env) else (sEval st2 env) 
sEval (x := e) env = undefined




pEval :: Pgm -> Env
pEval (Pgm lvar st) = undefined


 
factStmt :: Stmt
factStmt =
  "p" := Lit 1 ::: "n" := Lit 3 :::
  While (Not (Var "n" :==: Lit 0))
    ( "p" := Var "p" :*: Var "n" :::
      "n" := Var "n" :+: Lit (-1)
    )

test1 = Pgm [] factStmt 

{-CERINTE

1) (10pct) Finalizati definitia functiilor de interpretare.
2) (10pct) Adaugati instructiunea While BExp Stmt si interpretarea ei.
3) (20pct) Definiti interpretarea limbajului astfel incat programele sa se execute dintr-o stare 
initiala data iar  pEval  sa afiseze starea initiala si starea finala.

Definiti teste pentru verificarea solutiilor si indicati raspunsurile primite. 

-}