# -*- coding: utf-8 -*-
"""Lab02.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QJCYKhTSu7Xt68O4eQt7YSFVI5SDEjNo
"""

from sklearn.naive_bayes import MultinomialNB
import sklearn.datasets as datasets
import numpy as np

train_images = np.loadtxt('data/train_images.txt')
train_labels = np.loadtxt('data/train_labels.txt').astype(np.int)

test_images = np.loadtxt('data/test_images.txt')
test_labels = np.loadtxt('data/test_labels.txt').astype(np.int)

bins = np.linspace(start = 150, stop = 190, num = 4, endpoint = False)
print(bins)
data = [(160,"F"), (165, "F"), (155, "F"), (172, "F"), (175, "B"), (180, "B"), (177, "B"), (190, "B")]

f = [i for (i,j) in data if j == "F"]
b = [i for (i,j) in data if j == "B"]

print(f, b)

f_to_bins = np.digitize(f,bins)
b_to_bins = np.digitize(b,bins)

print(f_to_bins, b_to_bins)

f178 = len([i for i in f_to_bins if i == 3])
b178 = len([i for i in b_to_bins if i == 3])

p_f = f178 / (f178 + b178)
p_b = b178 / (f178 + b178)
print(p_f)
print(p_b)

num_bins = 5
bins = np.linspace(start=0, stop=255, num=num_bins)

print(bins)

def values_to_bins(x, bins):
    x_to_bins = np.digitize(x, bins)
    return x_to_bins - 1

x_train = values_to_bins(train_images, bins)
x_test = values_to_bins(test_images, bins)

print(x_train.min())
print(x_train.max())

num_bins = 5

bins = np.linspace(start=0, stop=255, num=num_bins)

naive_bayes_model = MultinomialNB()
naive_bayes_model.fit(x_train, train_labels)

# p = naive_bayes_model.predict(x_test)
accuracy = naive_bayes_model.score(x_test, test_labels)

print(accuracy)

for num_bins in [3, 5, 7, 9, 11]:
    bins = np.linspace(0, 255, num=num_bins)

    train = values_to_bins(train_images, bins)
    test = values_to_bins(test_images, bins)

    naive_bayes_model = MultinomialNB()

    naive_bayes_model.fit(train, train_labels)
    score = naive_bayes_model.score(test, test_labels)
    print(num_bins, score)

def values_to_bins(x, bins):
    x_to_bins = np.digitize(x, bins)
    return x_to_bins-1
scores = []
for num_bins in [3, 5, 7, 9, 11]:
    bins = np.linspace(0, 255, num = num_bins)
    train = values_to_bins(train_images, bins)
    test = values_to_bins(test_images, bins)
    naive_bayes_model = MultinomialNB()
    naive_bayes_model.fit(train, train_labels)
    score = naive_bayes_model.score(test, test_labels)
    scores.append(score)
nrs = [3, 5, 7, 9, 11]

# max = nrs[scores.index(max(scores))]
bins = np.linspace(0, 255, num = 7)
train = values_to_bins(train_images, bins)
test = values_to_bins(test_images, bins)
naive_bayes_model = MultinomialNB()
naive_bayes_model.fit(train, train_labels)
p = naive_bayes_model.predict(test_images)
nr = 0
for i in range(len(p)):
    if nr >= 10:
        break
    if p[i] != test_labels[i]:
        nr+=1
        image = test_images[i]
        image = np.reshape(image, (28, 28))
        plt.title(f'{test_labels[i]} misclassified as {p[i]}')
        plt.imshow(image.astype(np.uint8), cmap='gray')
        plt.show()
#plt.show()

def confusion_matrix(test_labels,predict_labels):
    # matrix = [[0 for _ in range(10)] for _ in range(10)]
    matrix = np.zeros((10, 10))
    for i in range(len(test_labels)):
        matrix[test_labels[i]][predict_labels[i]] += 1
    return matrix

confusion_matrix(test_labels, p)

from sklearn.metrics import plot_confusion_matrix

plot_confusion_matrix(naive_bayes_model, test, y_true=test_labels, normalize='true')



































from sklearn.model_selection import train_test_split

data = datasets.load_iris()

X_train, X_test, y_train, y_test = train_test_split(data.data, data.target, test_size=0.20, random_state=42)

model = MultinomialNB()
model.fit(X_train, y_train)

model.predict(X_test) # predictions

model.score(X_test, y_test) # accuracy

ex1=0
k=0
for i in vect:
    if i[0]>=171:
        if i[0]<=180:
            if i[1]=='B':
                ex1+=1
            k+=1
print(ex1/k)

bins = np.linspace(start = 150.1, stop=190.1, num=4, endpoint=False)
print(bins)
data = [(160,"F"), (165, "F"), (155, "F"), (172, "F"), (175, "B"), (180, "B"), (177, "B"), (190, "B")]

f = [i for (i,j) in data if j == "F"]
b = [i for (i,j) in data if j == "B"]

print(f, b)

f_to_bins = np.digitize(f, bins)
b_to_bins = np.digitize(b, bins)
n_f_178 = len([i for i in f_to_bins if i == 3])
n_b_178 = len([i for i in b_to_bins if i == 3])
p_f_178 = n_f_178 / (n_f_178 + n_b_178)
p_b_178 = n_b_178 / (n_f_178 + n_b_178)
print(p_f_178)
print(p_b_178)

training_set = [(160, 'F'), (165, 'F'), (155, 'F'), (172, 'F'),
                (175, 'B'), (180, 'B'), (177, 'B'), (190, 'B')]
data = [i for (i, j) in training_set]
labels = [j for(i, j) in training_set]

bins = np.linspace(start=150 , stop=190 , num=4, endpoint=False)
print(bins)
data = np.digitize(data, bins)

print([j for i, j in training_set])
print(data)

def calc_prob(vec, id):
  return len([i for i in vec if i == id]) / len(vec)

def calc_cond_prob(gender, bin):
  restr_data = [data[i] for i in range(len(labels)) if labels[i] == gender]
  return calc_prob(restr_data, bin)

def solve(height, gender):
  cores_bin = np.digitize(height, bins)
  print(cores_bin, calc_cond_prob(gender, cores_bin), calc_prob(labels, gender), calc_prob(data, cores_bin))
  return calc_prob(labels, gender) * calc_cond_prob(gender, cores_bin) / calc_prob(data, cores_bin)

height = 177
print('Prob ca o pers de', height, 'sa fie fata:', solve(height, 'F'))
print('Prob ca o pers de', height, 'sa fie baiat:', solve(height, 'B'))

# train_images = np.load('data/train_images.txt', allow_pickle=True)
# test_images = np.load('data/test_images.txt')
# train_labels = np.load('data/train_labels.txt', allow_pickle=True)
# test_labels = np.load('data/test_labels.txt')

def read_labels(path):
    with open(path) as f:
        lines = f.readlines()
        numbs = []
        for l in lines:
            numbs.append(float(l))
        return np.array(numbs)

def read_images(path):
    with open(path) as f:
        lines = f.readlines()
        numbs = []
        for l in lines:
            numbers = [float(x) for x in l.split(' ')]
            numbs.append(numbers)
        return np.array(numbs)

    
train_images = read_images('data/train_images.txt')
test_images = read_images('data/test_images.txt')
print(train_images.shape)
print(train_images.shape)

    
train_labels = read_labels('data/train_labels.txt')
test_labels = read_labels('data/test_labels.txt')
print(train_labels.shape)
print(test_labels.shape)





num_bins = 5
bins = np.linspace(start=0, stop=255, num=num_bins)

def values_to_bins(x, bins):
    x_to_bins = np.digitize(x, bins)
    return x_to_bins - 1

x_train = values_to_bins(train_images, bins)
x_test = values_to_bins(test_images, bins)

print(x_train.shape)
print(x_train.mean())

num_bins = 5
bins = np.linspace(start=0, stop=255, num=num_bins, endpoint=False)

train_images_dig = values_to_bins(train_images, bins)
test_images_dig = values_to_bins(test_images, bins)

naive_bayes = MultinomialNB()
naive_bayes.fit(train_images_dig, train_labels)
naive_bayes.score(test_images_dig, test_labels)

num_bins = 5
for num_bins in range(3, 12, 2):
    bins = np.linspace(0, 255, num=num_bins)
    x_train = values_to_bins(train_images, bins)
    x_test = values_to_bins(test_images, bins)
    naive_bayes_model = MultinomialNB()
    naive_bayes_model.fit(x_train, train_labels)
    print(num_bins, naive_bayes_model.score(x_test, test_labels))

import matplotlib.pyplot as plt

num_bins = 7

train_images_dig = values_to_bins(train_images, bins)
test_images_dig = values_to_bins(test_images, bins)

naive_bayes_model = MultinomialNB()

naive_bayes_model.fit(train_images_dig, train_labels)

p = naive_bayes_model.predict(test_images_dig)
score = naive_bayes_model.score(test_images_dig, test_labels)

count = 10
for i in range(len(p)):
    if count == 0:
        break
    if p[i] != test_labels[i]:
        plt.imshow(test_images[i].reshape(28, 28), cmap='gray') # print(i)
        # plt.title(str(int(test_labels[i])), 'missclassified as', str(int(p[i])))
        plt.title('{} missclassified as {}'.format(int(test_labels[i]), int(p[i])))
        plt.show()
        count -= 1

