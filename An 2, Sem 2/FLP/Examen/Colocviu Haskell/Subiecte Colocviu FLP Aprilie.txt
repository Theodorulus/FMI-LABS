1. {-
Gasiti mai jos  un minilimbaj. Interpretarea este partial definita.
Un program este o expresie de tip Pgmiar rezultatul executiei este ultima stare a memoriei. 
Executia unui program se face apeland pEval.
-}


import Data.Maybe
import Data.List


type Name = String


data  Pgm  = Pgm [Name] Stmt
        deriving (Read, Show)


data Stmt = Skip | Stmt ::: Stmt | If BExp Stmt Stmt| Name := AExp
        deriving (Read, Show)


data AExp = Lit Integer | AExp :+: AExp | AExp :: AExp | Var Name
        deriving (Read, Show)


data BExp = BTrue | BFalse | AExp :==: AExp | Not BExp
        deriving (Read, Show)


infixr 2 :::
infix 3 :=
infix 4 :==:
infixl 6 :+:
infixl 7 ::




type Env = [(Name, Integer)]




 




aEval :: AExp -> Env -> Integer
aEval = undefined


bEval :: BExp -> Env -> Bool
bEval = undefined


sEval :: Stmt -> Env -> Env
sEval Skip env = env
sEval (st1 ::: st2) env = undefined
sEval (If b st1 st2) env =  if (bEval b env) then (sEval st1 env) else (sEval st2 env) 
sEval (x := e) env = undefined








pEval :: Pgm -> Env
pEval (Pgm lvar st) = undefined




 
factStmt :: Stmt
factStmt =
  "p" := Lit 1 ::: "n" := Lit 3 :::
  While (Not (Var "n" :==: Lit 0))
    ( "p" := Var "p" :*: Var "n" :::
      "n" := Var "n" :+: Lit (-1)
    )


test1 = Pgm [] factStmt 


{-CERINTE


1) (10pct) Finalizati definitia functiilor de interpretare.
2) (10pct) Adaugati instructiunea While BExp Stmt si interpretarea ei.
3) (20pct) Definiti interpretarea limbajului astfel incat programele sa se execute dintr-o stare 
initiala data iar  pEval  sa afiseze starea initiala si starea finala.


Definiti teste pentru verificarea solutiilor si indicati raspunsurile primite. 


-}


2. 

{-
Gasiti mai jos limbajul unui minicalculator si o interpretare partiala. 
Calculatorul are doua celule de memorie, care au valoarea initiala 0. Expresia `Mem := Expr` are urmatoarea semantica: 
`Expr` este evaluata, iar valoarea este pusa in `Mem`.  
Un program este o expresie de tip `Prog`iar rezultatul executiei este dat de valorile finale ale celulelor de memorie.
Testare se face apeland `run test`. 
-}


data Prog  = Stmt ::: Prog | Off
data Stmt  = Mem := Expr
data Mem = Mem1 | Mem2 
data Expr  =  M Mem | V Int | Expr :+ Expr


infixl 6 :+
infix 3 :=
infixr 2 :::


type Env = (Int,Int)   -- corespunzator celor doua celule de memorie (Mem1, Mem2)


  
expr ::  Expr -> Env -> Int
expr (e1 :+  e2) m = expr  e1 m + expr  e2 m
expr _ _ = undefined


stmt :: Stmt -> Env -> Env
stmt _ _ = undefined




prog :: Prog -> Env -> Env
prog Off m = m
prog _ _ = undefined


run :: Prog -> Env
run p = prog p (0, 0)




test1 = Mem1 := V 3 ::: Mem2 := M Mem1 :+ V 5 ::: Off
test2 = Mem2 := V 3 ::: Mem1 := V 4 ::: Mem2 := (M Mem1 :+ M Mem2) :+ V 5 ::: Off
test3 = Mem1 := V 3 :+  V 3 ::: Off


{-CERINTE


1) (10pct) Finalizati definitia functiilor de interpretare.
2) (10 pct) Adaugati expresia `e1 :/ e2` care evaluează expresiile e1 și e2, apoi
  - dacă valoarea lui e2 e diferită de 0, se evaluează la câtul împărțirii lui e1 la e2;
  - în caz contrar va afișa eroarea "împarțire la 0" și va încheia execuția.
3)(20pct) Definiti interpretarea  limbajului extins astfel incat executia unui program fara erori sa intoarca valoarea finala si un mesaj
   care retine toate modificarile celulelor de memorie (pentru fiecare instructiune `m :< v` se adauga 
   mesajul final `Celula m a fost modificata cu valoarea v`), mesajele pastrand ordine de efectuare a instructiunilor.  
    Rezolvați subiectul 3) în același fișier redenumind funcțiile de interpretare. 


Indicati testele pe care le-ati folosit in verificarea solutiilor. 


-}










3. {-
Gasiti mai jos limbajul unui minicalculator si o interpretare partiala. 
Memoria calculatorului este o stivă de valori (intregi), inițial vidă.
Un program este o listă de instrucțiuni iar rezultatul executiei este starea finală a memoriei.
Testare se face apeland prog test. 
-}


data Prog  = On [Stmt]
data Stmt
  = Push Int -- pune valoare pe stivă    s --> i s
  | Pop      -- elimină valoarea din vărful stivei            i s --> s
  | Plus     -- extrage cele 2 valori din varful stivei, le adună si pune rezultatul inapoi pe stivă i j s --> (i + j) s
  | Dup      -- adaugă pe stivă valoarea din vârful stivei    i s --> i i s


type Env = [Int]   -- corespunzator stivei care conține valorile salvate


stmt :: Stmt -> Env -> Env
stmt   = undefined


stmts :: [Stmt] -> Env -> Env
stmts   = undefined


prog :: Prog -> Env
prog (On ss) = stmts ss []


test1 = On [Push 3, Push 5, Plus]            -- [8]
test2 = On [Push 3, Dup, Plus]               -- [6]
test3 = On [Push 3, Push 4, Dup, Plus, Plus] -- [11]


{-CERINTE


1) (10pct) Finalizati definitia functiilor de interpretare (aruncați excepții dacă stiva nu are suficiente valori pentru o instrucțiune)
2) (10 pct) Adaugati instrucțiunea Loop ss care evaluează repetat lista de instrucțiuni ss până când stiva de valori are lungime 1
   -- On [Push 1, Push 2, Push 3, Push 4, Loop [Plus]]  -- [10]
3) (20pct) Modificați interpretarea limbajului extins astfel incat interpretarea unui program / instrucțiune / expresie
   să nu mai arunce excepții, ci să aibă tipul rezultat Maybe Env / Maybe Int, unde rezultatul final în cazul în care
   execuția programului încearcă să scoată/acceseze o valoare din stiva de valori vidă va fi Nothing.
   Rezolvați subiectul 3) în același fișier redenumind funcțiile de interpretare.


Indicati testele pe care le-ati folosit in verificarea solutiilor. 
-}
4. {-
Gasiti mai jos limbajul unui minicalculator si o interpretare partiala. 
Calculatorul are doua celule de memorie, care au valoarea initiala  0.
Instrucțiunea `mem :< expr` are urmatoarea semantica: 
`expr` este evaluata, iar valoarea este pusa in `mem`.  
Un program este o expresie de tip `Prog` care execută pe rănd toate instrucțiunile iar rezultatul executiei
este starea finală a memoriei. 
Testare se face apeland `prog test`. 
-}


data Prog  = On [Stmt]
data Stmt  = Mem :< Expr
data Mem = Mem1 | Mem2 
data Expr  =  M Mem | V Int | Expr :+ Expr




infixl 6 :+
infix 4 :<


type Env = (Int,Int)   -- corespunzator celor doua celule de memorie


  
expr ::  Expr -> Env -> Int
expr (e1 :+  e2) (m1,m2) = (expr  e1 (m1,m2)) + (expr  e2 (m1,m2))
expr _ _ = undefined


stmt :: Stmt -> Env -> Env
stmt _ _ = undefined


stmts :: [Stmt] -> Env -> Env
stmts _ _ = undefined


prog :: Prog -> Env
prog (On ss) = stmts ss (0, 0)






test1 = On [Mem1 :< V 3, Mem2 :< M Mem1 :+ V 5]
test2 = On [Mem2 :< V 3, Mem1 :< V 4, Mem2 :< (M Mem1 :+ M Mem2) :+ V 5]
test3 = On [Mem2 :< V 3 :+  V 3]


{-CERINTE


1) (10pct) Finalizati definitia functiilor de interpretare.
2) (10 pct) Adaugati expresia `e1 :/ e2` care evaluează expresiile e1 și e2, apoi
  - dacă valoarea lui e2 e diferită de 0, se evaluează la câtul împărțirii lui e1 la e2;
  - în caz contrar va afișa eroarea "împarțire la 0" și va încheia execuția.
3)(20pct) Definiti interpretarea  limbajului extins astfel incat interpretarea unui program / instrucțiune / expresie
   să aibă tipul rezultat `Either String Env`/ `Either String Int`, unde rezultatul final în cazul în care execuția programului
   întâlnește o împărțire la 0 va fi `Left "împarțire la 0"`.  
   Rezolvați subiectul 3) în același fișier redenumind funcțiile de interpretare. 




Indicati testele pe care le-ati folosit in verificarea solutiilor. 


-}




5. {-
Gasiti mai jos limbajul unui minicalculator si o interpretare partiala. 
Calculatorul are doua celule de memorie. Interpretarea instructiunilor este data mai jos. 


Un program este o expresie de tip Progiar rezultatul executiei este starea finala a memoriei
Testare se face apeland prog test. 
-}


type Env = (Int,Int)   -- corespunzator celor doua celule de memorie


data Prog  = On Env Stmt  -- Env reprezinta valorile initiale ale celulelor de memorie
data Stmt
    = Off
    | Expr :<< Stmt -- evalueaza Expr, pune rezultatul in Mem1, apoi executa Stmt
    | Expr :< Stmt  -- evalueaza Expr, pune rezultatul in Mem2, apoi executa Stmt
data Mem = Mem1 | Mem2 
data Expr  =  M Mem | V Int | Expr :+ Expr


infixl 6 :+
infixr 2 :<
infixr 2 :<<








expr ::  Expr -> Env -> Int
expr (e1 :+  e2) m = expr e1 m + expr e2 m
expr   = undefined


stmt :: Stmt -> Env -> Env
stmt Off m = m
stmt   = undefined


prog :: Prog -> Env
prog (On m s) = undefined




test1 = On (1,2) (V 3 :< M Mem1 :+ V 5 :<< Off)
test2 = On (0,0) (V 3 :<< M Mem2 :+ V 5 :< Off)
test3 = On (0,1) (V 3 :<< V 4 :< M Mem1 :+ M Mem2 :+ (V 5) :< Off)
test4 = On (-2,3)(M Mem1  :+  V 3 :< Off)


{-CERINTE


1) (10pct) Finalizati definitia functiilor de interpretare.
2) (10 pct) Adaugati expresiile If1 e1 e2 si If2 e1 e2  care evaluează  e1 daca Mem1, 
respectiv Mem2, este nenula si e2 in caz contrar.
3) (20pct) Definiti interpretarea  limbajului extins  astfel incat executia unui program  sa calculeze memoria finala,
  si numărul de accesări (scrieri și citiri) ale memoriilor Mem1 si Mem2 (se va calcula o singura
  valoare, insumand accesarile ambelor memorii, fara a lua in considerare initializarea). 
  Rezolvați subiectul 3) în același fișier, redenumind funcțiile de interpretare. 




Indicati testele pe care le-ati folosit in verificarea solutiilor. 


-}